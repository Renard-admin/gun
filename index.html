<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Draw Tracker | Ковбойская Дуэль</title>
    <!-- Загрузка Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Загрузка Font Awesome для иконок -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Шрифты: Inter для чистого современного вида и Bold Serif для заголовка -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crete+Round:ital@0;1&family=Inter:wght@400;600;700;900&display=swap');
        
        /* Цветовая схема: Черный (Primary), Неоновый Желтый (Accent) */
        :root {
            --color-primary: #111827; /* Dark Grey/Black */
            --color-accent: #fde047; /* Neon Yellow */
            --color-text: #ffffff;
            --color-error: #ef4444; /* Red */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-primary);
            color: var(--color-text);
        }
        h1 {
            font-family: 'Crete Round', serif;
            letter-spacing: 0.15em;
        }
        
        /* Стилизация кнопок в "Nike стиле": жирные, с акцентом */
        .modern-button {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background-color: var(--color-accent);
            color: var(--color-primary);
            font-weight: 900;
            border-radius: 0.75rem; /* Large rounded corners */
            box-shadow: 0 10px 15px -3px rgba(253, 224, 71, 0.3), 0 4px 6px -2px rgba(253, 224, 71, 0.05);
        }
        .modern-button:hover {
            box-shadow: 0 20px 25px -5px rgba(253, 224, 71, 0.5), 0 10px 10px -5px rgba(253, 224, 71, 0.04);
            transform: translateY(-2px);
        }
        .modern-button:disabled {
            background-color: #4b5563; /* Grey out when disabled */
            color: #d1d5db;
            box-shadow: none;
            cursor: not-allowed;
            transform: translateY(0);
        }

        /* Видео контейнер */
        #video-wrapper {
            box-shadow: 0 0 40px rgba(253, 224, 71, 0.4);
            border: 4px solid var(--color-accent);
        }
        #video-canvas {
            transform: scaleX(-1); /* Зеркальное отображение для фронтальной камеры */
        }
        
        /* Оверлей таймера */
        #countdown-overlay {
            z-index: 50;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        #countdown-text {
            text-shadow: 0 0 20px var(--color-accent);
        }
    </style>
    <!-- Загрузка Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Включение логов для отладки
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        setLogLevel('debug');

        // Глобальные переменные Canvas (обязательны для использования)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;
        window.firebaseInitialized = false;

        // Обязательная функция инициализации Firebase
        async function initFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase Config не предоставлен.");
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch(e) {
                console.error("Ошибка инициализации Firebase:", e);
                return;
            }
            
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Ошибка аутентификации Firebase:", error);
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = `ID Пользователя: ${userId}`;
                    window.firebaseInitialized = true;
                    console.log("Firebase инициализирован. User ID:", userId);
                    window.startGameLogic({ db, userId, appId });
                } else {
                    console.log("Пользователь не аутентифицирован.");
                }
            });
        }

        // Запуск инициализации при загрузке окна
        window.addEventListener('load', initFirebase);
    </script>

    <!-- Загрузка MediaPipe Pose для отслеживания позы -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="game-container" class="min-h-screen p-4 md:p-8 flex flex-col items-center justify-start">

    <!-- Заголовок и ID пользователя -->
    <header class="text-center mb-8 w-full max-w-4xl">
        <h1 class="text-4xl md:text-6xl font-black text-white uppercase mt-4">
            Quick Draw Tracker
        </h1>
        <p class="text-xs mt-2 text-gray-400" id="user-id-display">Ожидание аутентификации...</p>
    </header>

    <!-- Игровое поле -->
    <main class="w-full max-w-4xl flex flex-col items-center">
        
        <!-- Видео и Канвас Контейнер -->
        <div id="video-wrapper" class="relative w-full aspect-[16/9] bg-gray-900 rounded-2xl overflow-hidden shadow-2xl">
            <video id="webcam-video" style="display: none;"></video>
            <canvas id="video-canvas" class="w-full h-full object-cover"></canvas>

            <!-- Оверлей для Таймера -->
            <div id="countdown-overlay" class="absolute inset-0 flex items-center justify-center text-white text-9xl font-black hidden">
                <span id="countdown-text" class="text-9xl font-extrabold" style="color: var(--color-accent);">3</span>
            </div>

            <!-- Оверлей для Результатов -->
            <div id="result-overlay" class="absolute inset-0 flex flex-col items-center justify-center text-center p-4 hidden" style="background-color: rgba(0, 0, 0, 0.9);">
                <h2 id="result-winner" class="text-5xl md:text-7xl mb-4 font-black tracking-wider animate-pulse" style="color: var(--color-accent);"></h2>
                <p id="result-detail" class="text-lg md:text-2xl text-gray-300 mb-8 font-semibold"></p>
                <!-- Кнопка "Играть ещё раз" -->
                <button id="restart-game-btn" onclick="window.resetGame()" class="modern-button py-3 px-10 text-xl md:text-2xl w-full max-w-sm uppercase">
                    Сыграть ещё раз
                </button>
            </div>
        </div>
        
        <!-- Панель управления, Счёт и Режим -->
        <div class="w-full mt-6 p-6 rounded-2xl bg-gray-800 shadow-xl">
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <!-- Счёт P1 -->
                <div class="text-center p-4 rounded-xl bg-gray-900 shadow-inner border border-gray-700">
                    <h3 class="text-xl font-bold text-gray-300 flex items-center justify-center"><i class="fas fa-hand-point-right text-red-500 mr-2"></i> Игрок 1 (Правая)</h3>
                    <p class="text-5xl font-extrabold mt-1" id="score-p1" style="color: var(--color-accent);">0</p>
                    <span id="status-p1" class="text-sm block mt-2 font-semibold text-green-400">Готов</span>
                </div>

                <!-- Режим и Кнопка Start -->
                <div class="flex flex-col justify-between space-y-4">
                    <div class="text-center">
                        <h3 class="text-sm font-semibold text-gray-400 uppercase">Режим Игры: <span id="game-mode-name" class="text-white"></span></h3>
                        <select id="mode-selector" class="w-full p-3 bg-gray-900 text-white rounded-lg border border-gray-600 focus:ring-2 focus:ring-yellow-400 mt-2">
                            <option value="single">Дуэль (Кто первый)</option>
                            <option value="bestof3">Серия (До 3 побед)</option>
                            <option value="reload">Перезарядка (Сложнее)</option>
                        </select>
                    </div>
                    <button id="start-game-btn" onclick="window.prepareForDuel()" class="modern-button py-4 text-xl w-full uppercase">
                        Начать Дуэль!
                    </button>
                </div>
                
                <!-- Счёт P2 -->
                <div class="text-center p-4 rounded-xl bg-gray-900 shadow-inner border border-gray-700">
                    <h3 class="text-xl font-bold text-gray-300 flex items-center justify-center"><i class="fas fa-hand-point-left text-blue-500 mr-2"></i> Игрок 2 (Левая)</h3>
                    <p class="text-5xl font-extrabold mt-1" id="score-p2" style="color: var(--color-accent);">0</p>
                    <span id="status-p2" class="text-sm block mt-2 font-semibold text-green-400">Готов</span>
                </div>
            </div>
        </div>

        <!-- Сообщения об ошибках / Статус -->
        <div id="message-box" class="mt-4 w-full text-center p-3 rounded-lg bg-red-800/80 text-white font-bold hidden">
            Требуется разрешить доступ к камере для начала игры.
        </div>
    </main>

</div>

<script>
    // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ИГРЫ ---
    const GAME_STATES = {
        SETUP: 'SETUP',
        WAITING: 'WAITING',
        COUNTDOWN: 'COUNTDOWN',
        DRAW: 'DRAW',
        RELOAD: 'RELOAD',
        RESULT: 'RESULT'
    };
    
    let gameState = GAME_STATES.SETUP;
    let scores = { p1: 0, p2: 0 };
    let duelStartTime = 0;
    let mode = 'single';
    let p1DrawnTime = 0;
    let p2DrawnTime = 0;

    const videoElement = document.getElementById('webcam-video');
    const canvasElement = document.getElementById('video-canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const countdownOverlay = document.getElementById('countdown-overlay');
    const countdownText = document.getElementById('countdown-text');
    const resultOverlay = document.getElementById('result-overlay');
    const startButton = document.getElementById('start-game-btn');
    const modeSelector = document.getElementById('mode-selector');
    const messageBox = document.getElementById('message-box');
    const modeNameDisplay = document.getElementById('game-mode-name');

    // --- FIREBASE / PERSISTENCE (ОБЯЗАТЕЛЬНЫЙ ШАБЛОН) ---
    let firestoreDB, currentUserId, currentAppId;

    window.startGameLogic = ({ db, userId, appId }) => {
        firestoreDB = db;
        currentUserId = userId;
        currentAppId = appId;
        console.log("Логика игры запущена с Firebase.");
        setupGamePersistence();
        setupWebcam();
    };
    
    // Путь к приватным данным: /artifacts/{appId}/users/{userId}/game_data
    function getGameDocRef() {
        if (!firestoreDB || !currentUserId || !currentAppId) return null;
        // Используем doc() с явным путем для получения ссылки на документ
        const path = `/artifacts/${currentAppId}/users/${currentUserId}/game_data/quickdraw_state`;
        return firestoreDB.doc(path);
    }

    async function setupGamePersistence() {
        const docRef = getGameDocRef();
        if (!docRef) {
            console.warn("Невозможно получить ссылку на документ Firestore.");
            return;
        }

        try {
            // 1. Загрузка/Инициализация состояния
            const docSnap = await firestoreDB.getDoc(docRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                scores.p1 = data.p1Score || 0;
                scores.p2 = data.p2Score || 0;
                mode = data.mode || 'single';
                modeSelector.value = mode;
                updateUI();
            } else {
                // Установка начального состояния, если документа нет
                await firestoreDB.setDoc(docRef, { p1Score: 0, p2Score: 0, mode: 'single' });
            }
            
            // 2. Подписка на обновления в реальном времени
            firestoreDB.onSnapshot(docRef, (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    scores.p1 = data.p1Score || 0;
                    scores.p2 = data.p2Score || 0;
                    
                    const newMode = data.mode || 'single';
                    if (mode !== newMode) {
                        mode = newMode;
                        modeSelector.value = mode;
                    }
                    updateUI();
                }
            });

            // Слушатель для смены режима
            modeSelector.addEventListener('change', (e) => {
                mode = e.target.value;
                scores.p1 = 0; // Сброс счета при смене режима
                scores.p2 = 0;
                saveGameState(); // Сохраняем новый режим и сброшенный счет
                updateUI();
            });

        } catch (e) {
            console.error("Ошибка при работе с Firestore:", e);
        }
    }

    async function saveGameState() {
        const docRef = getGameDocRef();
        if (!docRef) return;
        try {
            await firestoreDB.setDoc(docRef, { p1Score: scores.p1, p2Score: scores.p2, mode: mode }, { merge: true });
        } catch (e) {
            console.error("Ошибка сохранения состояния игры:", e);
        }
    }

    // --- MEDIA PIPE POSE И НАСТРОЙКА ВЕБ-КАМЕРЫ ---
    let pose;
    
    function setupWebcam() {
        if (!window.firebaseInitialized) {
            setTimeout(setupWebcam, 50); // Ждем инициализации Firebase
            return;
        }
        
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    videoElement.srcObject = stream;
                    videoElement.play();
                    videoElement.onloadedmetadata = () => {
                        // Адаптивное управление размером canvas
                        const aspectRatio = videoElement.videoWidth / videoElement.videoHeight;
                        const wrapper = document.getElementById('video-wrapper');
                        
                        canvasElement.width = videoElement.videoWidth;
                        canvasElement.height = videoElement.videoHeight;
                        
                        // Принудительная установка размера обертки для адаптивности
                        wrapper.style.height = `${wrapper.offsetWidth / aspectRatio}px`;

                        initializePose();
                        gameState = GAME_STATES.WAITING;
                        updateUI();
                        messageBox.classList.add('hidden');
                    };
                })
                .catch(error => {
                    console.error("Не удалось получить доступ к камере:", error);
                    messageBox.textContent = "Ошибка: Не удалось получить доступ к камере. Разрешите доступ и обновите страницу.";
                    messageBox.classList.remove('hidden');
                    startButton.disabled = true;
                });
        } else {
            messageBox.textContent = "Ваш браузер не поддерживает MediaDevices API (веб-камеру).";
            messageBox.classList.remove('hidden');
            startButton.disabled = true;
        }
    }

    function initializePose() {
        pose = new Pose({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        }});

        pose.setOptions({
            modelComplexity: 1, 
            smoothLandmarks: true,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        pose.onResults(onResults);

        // Запуск потока обработки
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        camera.start();
    }

    // --- ЛОГИКА ОТСЛЕЖИВАНИЯ ПОЗЫ ---
    
    /**
     * Вычисляет угол между тремя точками (A, B, C) в 2D пространстве.
     */
    function calculateAngle(A, B, C) {
        const radians = Math.atan2(C.y - B.y, C.x - B.x) - Math.atan2(A.y - B.y, A.x - B.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) {
            angle = 360 - angle;
        }
        return angle;
    }

    /**
     * Проверяет, "вытащен" ли пистолет (горизонтальная рука 90-180 градусов, выпрямленная).
     */
    function isDrawn(landmarks, shoulderIndex, elbowIndex, wristIndex) {
        if (!landmarks[shoulderIndex] || !landmarks[elbowIndex] || !landmarks[wristIndex]) return false;

        const shoulder = landmarks[shoulderIndex];
        const elbow = landmarks[elbowIndex];
        const wrist = landmarks[wristIndex];

        // 1. Угол в локте (должен быть почти прямой, рука выпрямлена)
        const elbowAngle = calculateAngle(shoulder, elbow, wrist);
        const isStraight = elbowAngle > 165; // Допуск 165-180 градусов

        // 2. Горизонтальное/Верхнее положение (запястье выше или на уровне плеча)
        // Чем меньше Y, тем выше точка (MediaPipe: (0,0) в верхнем левом углу)
        const isHigh = wrist.y < shoulder.y - 0.05; // Запястье заметно выше плеча
        
        return isStraight && isHigh;
    }
    
    /**
     * Проверяет, "перезаряжена" ли рука (опущена).
     */
    function isReloaded(landmarks, shoulderIndex, wristIndex) {
        if (!landmarks[shoulderIndex] || !landmarks[wristIndex]) return false;

        const shoulder = landmarks[shoulderIndex];
        const wrist = landmarks[wristIndex];

        // Проверка: запястье должно быть ниже плеча (чем больше Y, тем ниже)
        const isLow = wrist.y > shoulder.y + 0.1; 
        
        return isLow;
    }


    // --- ГЛАВНЫЙ ЦИКЛ ОБРАБОТКИ РЕЗУЛЬТАТОВ POSE ---

    function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // Рисуем видеопоток, зеркально отраженный, чтобы P1 был слева, P2 справа
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        const landmarks = results.poseLandmarks;
        
        if (landmarks) {
            
            // Player 1 (P1) - Правая рука (Для игрока слева на экране)
            const P1_SHOULDER = 12; 
            const P1_ELBOW = 14;   
            const P1_WRIST = 16;   

            // Player 2 (P2) - Левая рука (Для игрока справа на экране)
            const P2_SHOULDER = 11; 
            const P2_ELBOW = 13;   
            const P2_WRIST = 15;   
            
            // Рисуем все точки и соединения
            drawConnectors(canvasCtx, landmarks, POSE_CONNECTIONS,
                           {color: 'rgba(255, 255, 255, 0.4)', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks,
                          {color: '#fde047', lineWidth: 2, radius: 4});
            
            // Визуальная обратная связь для рук
            if (landmarks[P1_WRIST]) {
                const p1Ready = isReloaded(landmarks, P1_SHOULDER, P1_WRIST);
                drawLandmarks(canvasCtx, [landmarks[P1_WRIST]], {
                    color: p1Ready ? '#34d399' : '#fde047', // Зеленый, если рука опущена (готова), Желтый, если поднята/не готова
                    fillColor: p1Ready ? '#059669' : '#b45309',
                    radius: 8
                });
            }
            if (landmarks[P2_WRIST]) {
                const p2Ready = isReloaded(landmarks, P2_SHOULDER, P2_WRIST);
                drawLandmarks(canvasCtx, [landmarks[P2_WRIST]], {
                    color: p2Ready ? '#34d399' : '#fde047',
                    fillColor: p2Ready ? '#059669' : '#b45309',
                    radius: 8
                });
            }
            
            // --- ЛОГИКА ИГРЫ В РЕАЛЬНОМ ВРЕМЕНИ ---

            if (gameState === GAME_STATES.DRAW) {
                // 1. Проверка P1 (Правая рука)
                if (p1DrawnTime === 0 && isDrawn(landmarks, P1_SHOULDER, P1_ELBOW, P1_WRIST)) {
                    p1DrawnTime = performance.now();
                }

                // 2. Проверка P2 (Левая рука)
                if (p2DrawnTime === 0 && isDrawn(landmarks, P2_SHOULDER, P2_ELBOW, P2_WRIST)) {
                    p2DrawnTime = performance.now();
                }

                // 3. Определение победителя
                if (p1DrawnTime > 0 || p2DrawnTime > 0) {
                    determineWinner();
                }
            } else if (gameState === GAME_STATES.RELOAD) {
                // Проверка, что руки опущены (перезаряжены)
                const p1Reloaded = isReloaded(landmarks, P1_SHOULDER, P1_WRIST);
                const p2Reloaded = isReloaded(landmarks, P2_SHOULDER, P2_WRIST);
                
                document.getElementById('status-p1').textContent = p1Reloaded ? 'Готов к дуэли' : 'Перезарядка...';
                document.getElementById('status-p2').textContent = p2Reloaded ? 'Готов к дуэли' : 'Перезарядка...';

                if (p1Reloaded && p2Reloaded) {
                    // Оба перезаряжены, возвращаемся в WAITING для следующего раунда.
                    gameState = GAME_STATES.WAITING;
                    updateUI();
                }
            }
        }
        canvasCtx.restore();
    }

    // --- ЛОГИКА ИГРОВОГО ПРОЦЕССА ---

    // Воспроизведение звука (гудка)
    function playBeep(frequency, duration, volume, callback) {
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

            oscillator.start();
            
            setTimeout(() => {
                // Плавное затухание
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
                oscillator.stop();
                if (callback) callback();
            }, duration);
        } catch (e) {
            console.warn("AudioContext error, cannot play sound.", e);
            if (callback) callback();
        }
    }

    // Запуск таймера
    window.prepareForDuel = () => {
        if (gameState !== GAME_STATES.WAITING) return;

        // Сброс временных меток
        p1DrawnTime = 0;
        p2DrawnTime = 0;
        duelStartTime = 0;

        gameState = GAME_STATES.COUNTDOWN;
        updateUI();
        countdownOverlay.classList.remove('hidden');
        
        let count = 3;
        
        function tick() {
            if (count > 0) {
                countdownText.textContent = count;
                const freq = count === 1 ? 800 : 550; // Последний гудок выше
                const vol = count === 1 ? 0.7 : 0.4; // Последний гудок громче
                playBeep(freq, 400, vol, () => {
                    count--;
                    if (count > 0) {
                        setTimeout(tick, 1000);
                    } else {
                        // GO!
                        countdownText.textContent = 'ОГОНЬ!';
                        countdownText.style.color = 'var(--color-error)';
                        playBeep(1200, 50, 0.9); // Короткий, резкий сигнал
                        
                        gameState = GAME_STATES.DRAW;
                        duelStartTime = performance.now();
                        updateUI();
                        // Скрыть через 700мс
                        setTimeout(() => {
                            countdownOverlay.classList.add('hidden');
                            countdownText.style.color = 'var(--color-accent)';
                        }, 700);
                    }
                });
            }
        }
        tick();
    };

    function determineWinner() {
        gameState = GAME_STATES.RESULT;
        
        let winner = null;
        let p1Time = p1DrawnTime > 0 ? (p1DrawnTime - duelStartTime) / 1000 : Infinity;
        let p2Time = p2DrawnTime > 0 ? (p2DrawnTime - duelStartTime) / 1000 : Infinity;
        let winTime = 0;

        if (p1Time < p2Time) {
            winner = 1;
            winTime = p1Time;
        } else if (p2Time < p1Time) {
            winner = 2;
            winTime = p2Time;
        } else if (p1DrawnTime > 0 && p2DrawnTime > 0) {
            winner = 0; // Ничья
        } else {
            winner = 3; // Никто не победил (не должно случиться здесь)
        }

        displayResult(winner, winTime);
    }
    
    function displayResult(winner, time) {
        const resultWinnerEl = document.getElementById('result-winner');
        const resultDetailEl = document.getElementById('result-detail');
        
        if (winner === 1) {
            resultWinnerEl.textContent = 'ИГРОК 1 ПОБЕЖДАЕТ!';
            resultDetailEl.textContent = `Время реакции: ${time.toFixed(3)} сек.`;
            scores.p1++;
        } else if (winner === 2) {
            resultWinnerEl.textContent = 'ИГРОК 2 ПОБЕЖДАЕТ!';
            resultDetailEl.textContent = `Время реакции: ${time.toFixed(3)} сек.`;
            scores.p2++;
        } else if (winner === 0) {
            resultWinnerEl.textContent = 'НИЧЬЯ!';
            resultDetailEl.textContent = `Оба выстрелили одновременно!`;
        } else {
            resultWinnerEl.textContent = 'ПРОМАХ!';
            resultDetailEl.textContent = `Попробуйте еще раз.`;
        }

        let isSeriesOver = false;
        if (mode === 'bestof3' && (scores.p1 >= 3 || scores.p2 >= 3)) {
            const seriesWinner = scores.p1 >= 3 ? 'Игрок 1' : 'Игрок 2';
            resultWinnerEl.textContent = `ПОБЕДА В СЕРИИ: ${seriesWinner}!`;
            resultDetailEl.textContent = `Финальный счет: ${scores.p1} - ${scores.p2}`;
            isSeriesOver = true;
        }
        
        resultOverlay.classList.remove('hidden');
        saveGameState(); // Сохранение нового счета
        updateUI(isSeriesOver);
    }
    
    // Сброс для следующего раунда / новой игры
    window.resetGame = () => {
        resultOverlay.classList.add('hidden');
        p1DrawnTime = 0;
        p2DrawnTime = 0;
        
        const isSeriesOver = (mode === 'bestof3' && (scores.p1 >= 3 || scores.p2 >= 3));

        if (isSeriesOver) {
             // Сброс счета, если серия окончена
            scores.p1 = 0;
            scores.p2 = 0;
            saveGameState();
            gameState = GAME_STATES.WAITING;
        } else if (mode === 'reload') {
            // Если режим "Перезарядка", требуется опустить руки
            gameState = GAME_STATES.RELOAD;
        } else {
            // Обычный сброс
            gameState = GAME_STATES.WAITING;
        }

        updateUI(isSeriesOver);
    };
    
    // --- ОБНОВЛЕНИЕ UI ---

    function updateUI(seriesOver = false) {
        document.getElementById('score-p1').textContent = scores.p1;
        document.getElementById('score-p2').textContent = scores.p2;
        modeNameDisplay.textContent = modeSelector.options[modeSelector.selectedIndex].textContent;

        const p1Status = document.getElementById('status-p1');
        const p2Status = document.getElementById('status-p2');
        
        startButton.disabled = true; // По умолчанию отключаем

        if (gameState === GAME_STATES.WAITING) {
            startButton.disabled = false;
            startButton.textContent = 'Начать Дуэль!';
            p1Status.textContent = 'Готов';
            p2Status.textContent = 'Готов';
            p1Status.classList.remove('text-red-400');
            p2Status.classList.remove('text-red-400');
            p1Status.classList.add('text-green-400');
            p2Status.classList.add('text-green-400');
        } else if (gameState === GAME_STATES.RELOAD) {
            startButton.textContent = 'Ожидание перезарядки...';
            p1Status.textContent = 'ПЕРЕЗАРЯДИТЬ';
            p2Status.textContent = 'ПЕРЕЗАРЯДИТЬ';
            p1Status.classList.add('text-red-400');
            p2Status.classList.add('text-red-400');
            p1Status.classList.remove('text-green-400');
            p2Status.classList.remove('text-green-400');
        } else if (gameState === GAME_STATES.COUNTDOWN) {
            startButton.textContent = 'ВНИМАНИЕ!';
            p1Status.textContent = 'ВНИМАНИЕ';
            p2Status.textContent = 'ВНИМАНИЕ';
        } else if (gameState === GAME_STATES.DRAW) {
            startButton.textContent = 'ОГОНЬ! ВЫСТРЕЛ!';
            p1Status.textContent = 'ВЫСТРЕЛ!';
            p2Status.textContent = 'ВЫСТРЕЛ!';
        } else if (gameState === GAME_STATES.RESULT) {
            startButton.textContent = 'Результаты...';
            p1Status.textContent = 'СТОП';
            p2Status.textContent = 'СТОП';
            
            document.getElementById('restart-game-btn').textContent = seriesOver ? 'Начать новую серию' : 'Сыграть ещё раз';
        }
    }
</script>

</body>
</html>

